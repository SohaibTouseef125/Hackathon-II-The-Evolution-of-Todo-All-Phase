---
name: production-frontend
description: Comprehensive production-ready frontend development with React, Next.js, TypeScript, and modern architecture patterns. Use when Claude needs to work with production frontend applications for creating React components, implementing Next.js applications with App Router, setting up TypeScript configurations, implementing state management solutions, following accessibility best practices, implementing responsive design, setting up testing frameworks, or any other production frontend development tasks.
---

# Production Frontend Development

## Overview

This skill provides comprehensive guidance for building production-ready frontend applications using modern technologies and best practices. It covers React/Next.js development, TypeScript configuration, state management, responsive design, accessibility, testing, and deployment strategies. The skill ensures applications are scalable, maintainable, and follow industry standards.

## Core Capabilities

### 1. React Component Architecture
- Component design patterns (presentational vs container, compound components)
- Performance optimization (React.memo, useCallback, useMemo)
- Custom hooks development
- Context API and state management
- Error boundaries and fallback UI

### 2. Next.js Application Development
- App Router implementation (Next.js 13+)
- Server and Client Component patterns
- Data fetching strategies (SSR, SSG, ISR)
- API routes and middleware
- Image optimization and asset handling

### 3. TypeScript Integration
- Type definitions and interfaces
- Strict mode configuration
- Utility types and generics
- React-specific TypeScript patterns
- API response typing

### 4. Styling and Responsive Design
- CSS-in-JS solutions (Styled Components, Emotion)
- Utility-first CSS (Tailwind CSS)
- Responsive design patterns
- CSS Modules and component styling
- Design system implementation

### 5. Testing Frameworks
- Unit testing with Jest and React Testing Library
- Integration testing patterns
- End-to-end testing with Playwright/Cypress
- Component testing with Storybook
- Test coverage and CI integration

### 6. Performance Optimization
- Bundle size optimization
- Code splitting and lazy loading
- Image optimization techniques
- Caching strategies
- Web Vitals monitoring

## Project Structure

### Recommended Monorepo Structure
```
production-frontend/
├── apps/
│   └── web/
│       ├── app/
│       │   ├── layout.tsx
│       │   ├── page.tsx
│       │   ├── globals.css
│       │   └── [...slug]/
│       │       └── page.tsx
│       ├── components/
│       │   ├── ui/
│       │   ├── forms/
│       │   └── sections/
│       ├── lib/
│       │   ├── utils.ts
│       │   ├── api.ts
│       │   └── types.ts
│       ├── hooks/
│       ├── styles/
│       ├── public/
│       ├── package.json
│       └── next.config.js
├── packages/
│   ├── ui/
│   ├── types/
│   ├── hooks/
│   └── utils/
├── specs/
├── tests/
├── docs/
├── .github/
│   └── workflows/
├── .specify/
└── tooling/
    ├── eslint/
    ├── prettier/
    └── typescript/
```

## Frontend Implementation Patterns

### 1. Next.js App Router Setup
```tsx
// app/layout.tsx
import './globals.css'
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Production Frontend App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
```

### 2. TypeScript Type Definitions
```typescript
// lib/types.ts
export interface User {
  id: string
  name: string
  email: string
  avatar?: string
  createdAt: string
}

export interface ApiResponse<T> {
  data: T
  message?: string
  success: boolean
  errors?: string[]
}

export type FormState = {
  loading: boolean
  error?: string
  success?: boolean
}
```

### 3. Custom React Hook Example
```typescript
// hooks/useApi.ts
import { useState, useEffect } from 'react'

export function useApi<T>(url: string) {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true)
        const response = await fetch(url)
        if (!response.ok) throw new Error('Network response was not ok')
        const result = await response.json()
        setData(result)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred')
      } finally {
        setLoading(false)
      }
    }

    fetchData()
  }, [url])

  return { data, loading, error }
}
```

### 4. Component with TypeScript and React Best Practices
```tsx
// components/ui/Button.tsx
import React, { ButtonHTMLAttributes, forwardRef } from 'react'
import { cva, type VariantProps } from 'class-variance-authority'
import { cn } from '@/lib/utils'

const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

export interface ButtonProps
  extends ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = 'Button'

export { Button, buttonVariants }
```

## State Management Solutions

### 1. Context API Pattern
```typescript
// context/UserContext.tsx
import { createContext, useContext, useReducer, ReactNode } from 'react'
import { User } from '@/lib/types'

type UserState = {
  user: User | null
  loading: boolean
}

type UserAction =
  | { type: 'SET_USER'; payload: User }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'LOGOUT' }

const initialState: UserState = {
  user: null,
  loading: false,
}

const UserContext = createContext<{
  state: UserState
  dispatch: React.Dispatch<UserAction>
} | undefined>(undefined)

const userReducer = (state: UserState, action: UserAction): UserState => {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload }
    case 'SET_LOADING':
      return { ...state, loading: action.payload }
    case 'LOGOUT':
      return { ...state, user: null }
    default:
      return state
  }
}

export function UserProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(userReducer, initialState)

  return (
    <UserContext.Provider value={{ state, dispatch }}>
      {children}
    </UserContext.Provider>
  )
}

export function useUser() {
  const context = useContext(UserContext)
  if (!context) {
    throw new Error('useUser must be used within a UserProvider')
  }
  return context
}
```

### 2. Client-Side Data Fetching with SWR
```typescript
// lib/swr.ts
import useSWR from 'swr'
import { User } from '@/lib/types'

const fetcher = (url: string) => fetch(url).then(res => res.json())

export function useUser(id: string) {
  const { data, error, mutate } = useSWR<User>(`/api/users/${id}`, fetcher)

  return {
    user: data,
    isLoading: !error && !data,
    isError: error,
    mutate
  }
}
```

## Testing Implementation

### 1. Component Testing with React Testing Library
```typescript
// components/ui/Button.test.tsx
import { render, screen } from '@testing-library/react'
import { Button } from './Button'

describe('Button', () => {
  it('renders children correctly', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByText('Click me')).toBeInTheDocument()
  })

  it('applies correct variant classes', () => {
    render(<Button variant="destructive">Danger</Button>)
    const button = screen.getByText('Danger')
    expect(button).toHaveClass('bg-destructive')
  })

  it('applies disabled state', () => {
    render(<Button disabled>Disabled</Button>)
    const button = screen.getByText('Disabled')
    expect(button).toBeDisabled()
  })
})
```

### 2. API Route Testing
```typescript
// app/api/users/route.test.ts
import { GET } from './route'
import { NextRequest } from 'next/server'

// Mock the database
jest.mock('@/lib/db', () => ({
  getUser: jest.fn()
}))

describe('Users API Route', () => {
  it('should return user data', async () => {
    const request = new NextRequest('http://localhost:3000/api/users/1', {
      method: 'GET'
    })

    const response = await GET(request, { params: { id: '1' } })
    const data = await response.json()

    expect(response.status).toBe(200)
    expect(data).toHaveProperty('user')
  })
})
```

## Performance Optimization

### 1. Code Splitting with Dynamic Imports
```tsx
// components/LazyComponent.tsx
import dynamic from 'next/dynamic'

const HeavyComponent = dynamic(
  () => import('./HeavyComponent'),
  {
    loading: () => <div>Loading...</div>,
    ssr: false // Only render on client side
  }
)

// components/WithSidebar.tsx
const Sidebar = dynamic(() => import('./Sidebar'), {
  loading: () => <div className="w-64 h-full bg-gray-100 animate-pulse" />
})
```

### 2. Image Optimization
```tsx
// components/ProductImage.tsx
import Image from 'next/image'

export default function ProductImage({
  src,
  alt,
  width = 300,
  height = 300
}: {
  src: string
  alt: string
  width?: number
  height?: number
}) {
  return (
    <Image
      src={src}
      alt={alt}
      width={width}
      height={height}
      priority={false}
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      style={{
        width: '100%',
        height: 'auto',
      }}
    />
  )
}
```

## Accessibility Best Practices

### 1. Accessible Form Components
```tsx
// components/forms/Input.tsx
import React, { InputHTMLAttributes, forwardRef } from 'react'
import { cn } from '@/lib/utils'

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label: string
  error?: string
  helperText?: string
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, error, helperText, className, ...props }, ref) => {
    const id = props.id || `input-${Math.random().toString(36).substr(2, 9)}`

    return (
      <div className="space-y-1">
        <label
          htmlFor={id}
          className="block text-sm font-medium text-gray-700"
        >
          {label}
        </label>
        <input
          id={id}
          ref={ref}
          className={cn(
            'block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm',
            error && 'border-red-500',
            className
          )}
          aria-invalid={!!error}
          aria-describedby={error ? `${id}-error` : undefined}
          {...props}
        />
        {helperText && (
          <p className="text-xs text-gray-500" id={`${id}-helper`}>
            {helperText}
          </p>
        )}
        {error && (
          <p className="text-xs text-red-600" id={`${id}-error`}>
            {error}
          </p>
        )}
      </div>
    )
  }
)

Input.displayName = 'Input'
export { Input }
```

## Deployment Configuration

### 1. Next.js Configuration
```javascript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    typedRoutes: true,
  },
  images: {
    domains: ['example.com', 'cdn.example.com'],
    formats: ['image/webp', 'image/avif'],
  },
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin',
          },
        ],
      },
    ]
  },
  async redirects() {
    return [
      {
        source: '/v1/:path*',
        destination: '/:path*',
        permanent: true,
      },
    ]
  },
}

module.exports = nextConfig
```

### 2. Environment Configuration
```bash
# .env.example
NEXT_PUBLIC_API_URL=https://api.example.com
NEXT_PUBLIC_APP_ENV=production
NEXT_PUBLIC_SENTRY_DSN=https://example@sentry.io/123

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/mydb

# Authentication
NEXTAUTH_SECRET=your-secret-key
NEXTAUTH_URL=http://localhost:3000

# Third-party services
RESEND_API_KEY=your-resend-key
STRIPE_SECRET_KEY=your-stripe-key
```

## Quality Assurance Framework

### 1. ESLint Configuration
```javascript
// tooling/eslint/base.js
module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true,
  },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'next/core-web-vitals',
    'prettier',
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: 'latest',
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint', 'import', 'unused-imports'],
  rules: {
    'no-unused-vars': 'off',
    'no-console': 'warn',
    'import/order': [
      'error',
      {
        groups: [
          'builtin',
          'external',
          'internal',
          'parent',
          'sibling',
          'index',
        ],
        pathGroups: [
          {
            pattern: 'react+(-native|/native|)',
            group: 'external',
            position: 'before',
          },
          {
            pattern: '@/types/**',
            group: 'index',
            position: 'after',
          },
        ],
        pathGroupsExcludedImportTypes: ['react'],
        alphabetize: {
          order: 'asc',
          caseInsensitive: true,
        },
      },
    ],
    'unused-imports/no-unused-imports': 'error',
    'unused-imports/no-unused-vars': [
      'warn',
      {
        vars: 'all',
        varsIgnorePattern: '^_',
        args: 'after-used',
        argsIgnorePattern: '^_',
      },
    ],
  },
  settings: {
    'import/resolver': {
      typescript: {
        project: './tsconfig.json',
      },
    },
  },
}
```

### 2. Prettier Configuration
```json
// tooling/prettier/index.json
{
  "$schema": "https://json.schemastore.org/prettierrc",
  "semi": true,
  "tabWidth": 2,
  "singleQuote": true,
  "printWidth": 80,
  "trailingComma": "es5",
  "importOrder": [
    "^(react/(.*)$)|^(react$)",
    "^(next/(.*)$)|^(next$)",
    "<THIRD_PARTY_MODULES>",
    "^@/types/(.*)$",
    "^@/lib/(.*)$",
    "^@/hooks/(.*)$",
    "^@/components/ui/(.*)$",
    "^@/components/(.*)$",
    "^@/styles/(.*)$",
    "^@/app/(.*)$",
    "^[./]"
  ],
  "importOrderSeparation": true,
  "importOrderSortSpecifiers": true,
  "plugins": ["@ianvs/prettier-plugin-sort-imports"]
}
```

## Development Workflow

### 1. Project Initialization
1. Set up Next.js project with TypeScript
2. Configure ESLint and Prettier
3. Set up component library (e.g., shadcn/ui)
4. Configure testing framework (Jest + React Testing Library)
5. Set up CI/CD pipeline

### 2. Component Development Process
1. Define TypeScript interfaces for props
2. Create component with proper accessibility attributes
3. Write unit tests for component behavior
4. Add Storybook stories for visual testing
5. Document component usage in README

### 3. Code Review Checklist
- [ ] TypeScript types are properly defined
- [ ] Components are accessible (ARIA attributes, keyboard navigation)
- [ ] Performance optimizations implemented (memo, lazy loading)
- [ ] Tests cover edge cases and error states
- [ ] Code follows established patterns and conventions
- [ ] Security best practices followed (no XSS, proper validation)

## Resources

### references/
- `react_patterns.md` - React best practices and patterns
- `nextjs_configuration.md` - Next.js setup and optimization guides
- `typescript_guidelines.md` - TypeScript configuration and patterns
- `testing_strategies.md` - Comprehensive testing approaches
- `accessibility_standards.md` - WCAG compliance guidelines
- `performance_optimization.md` - Frontend performance techniques

### assets/
- `component_templates/` - Reusable component boilerplates
- `configuration_templates/` - ESLint, Prettier, TypeScript configs
- `design_system/` - Design tokens and style guides
- `testing_templates/` - Test file templates and utilities
